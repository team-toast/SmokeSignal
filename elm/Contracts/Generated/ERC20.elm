module Contracts.Generated.ERC20 exposing
    ( Approval
    , Transfer
    , allowance
    , approvalDecoder
    , approvalEvent
    , approve
    , balanceOf
    , totalSupply
    , transfer
    , transferDecoder
    , transferEvent
    , transferFrom
    )

import BigInt exposing (BigInt)
import Eth.Abi.Decode as D exposing (abiDecode, andMap, data, toElmDecoder, topic)
import Eth.Abi.Encode as E exposing (Encoding(..), abiEncode)
import Eth.Types exposing (..)
import Eth.Utils as U
import Json.Decode as Decode exposing (Decoder, succeed)
import Json.Decode.Pipeline exposing (custom)



{-

   This file was generated by https://github.com/cmditch/elm-ethereum-generator v4.0.0
   Compatible with elm-ethereum v4.0.0

-}
-- allowance(address,address) function


allowance : Address -> Address -> Address -> Call BigInt
allowance contractAddress owner_ spender_ =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "dd62ed3e" [ E.address owner_, E.address spender_ ]
    , nonce = Nothing
    , decoder = toElmDecoder D.uint
    }



-- approve(address,uint256) function


approve : Address -> Address -> BigInt -> Call Bool
approve contractAddress spender_ amount_ =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "095ea7b3" [ E.address spender_, E.uint amount_ ]
    , nonce = Nothing
    , decoder = toElmDecoder D.bool
    }



-- balanceOf(address) function


balanceOf : Address -> Address -> Call BigInt
balanceOf contractAddress account_ =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "70a08231" [ E.address account_ ]
    , nonce = Nothing
    , decoder = toElmDecoder D.uint
    }



-- totalSupply() function


totalSupply : Address -> Call BigInt
totalSupply contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "18160ddd" []
    , nonce = Nothing
    , decoder = toElmDecoder D.uint
    }



-- transfer(address,uint256) function


transfer : Address -> Address -> BigInt -> Call Bool
transfer contractAddress recipient_ amount_ =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "a9059cbb" [ E.address recipient_, E.uint amount_ ]
    , nonce = Nothing
    , decoder = toElmDecoder D.bool
    }



-- transferFrom(address,address,uint256) function


transferFrom : Address -> Address -> Address -> BigInt -> Call Bool
transferFrom contractAddress sender_ recipient_ amount_ =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "23b872dd" [ E.address sender_, E.address recipient_, E.uint amount_ ]
    , nonce = Nothing
    , decoder = toElmDecoder D.bool
    }



-- Approval(address,address,uint256) event


type alias Approval =
    { owner : Address
    , spender : Address
    , value : BigInt
    }


approvalEvent : Address -> Maybe Address -> Maybe Address -> LogFilter
approvalEvent contractAddress owner_ spender_ =
    { fromBlock = LatestBlock
    , toBlock = LatestBlock
    , address = contractAddress
    , topics =
        [ Just <| U.unsafeToHex "8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925"
        , Maybe.map (abiEncode << E.address) owner_
        , Maybe.map (abiEncode << E.address) spender_
        ]
    }


approvalDecoder : Decoder Approval
approvalDecoder =
    Decode.succeed Approval
        |> custom (topic 1 D.address)
        |> custom (topic 2 D.address)
        |> custom (data 0 D.uint)



-- Transfer(address,address,uint256) event


type alias Transfer =
    { from : Address
    , to : Address
    , value : BigInt
    }


transferEvent : Address -> Maybe Address -> Maybe Address -> LogFilter
transferEvent contractAddress from_ to_ =
    { fromBlock = LatestBlock
    , toBlock = LatestBlock
    , address = contractAddress
    , topics =
        [ Just <| U.unsafeToHex "ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"
        , Maybe.map (abiEncode << E.address) from_
        , Maybe.map (abiEncode << E.address) to_
        ]
    }


transferDecoder : Decoder Transfer
transferDecoder =
    Decode.succeed Transfer
        |> custom (topic 1 D.address)
        |> custom (topic 2 D.address)
        |> custom (data 0 D.uint)
